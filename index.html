<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>reveal.js</title>

  <link rel="stylesheet" href="dist/reset.css">
  <link rel="stylesheet" href="dist/reveal.css">
  <link rel="stylesheet" href="dist/theme/catppuccin.css">
  <!--		<link rel="stylesheet" href="dist/theme/black.css">-->

  <!-- Theme used for syntax highlighted code -->
  <link rel="stylesheet" href="plugin/highlight/monokai.css">
  <style>
      .fragment.blur {
          filter: blur(100px);
      }

      .fragment.blur.visible {
          filter: none;
      }

      .reveal pre code {
          display: block; /* Ensure block-level layout */
          overflow-y: auto; /* Add vertical scrollbar when needed */
          max-height: 400px; /* Set maximum height for the code block */
          word-wrap: normal; /* Prevent text wrapping to keep lines intact */
          white-space: pre; /* Preserve spaces and line breaks in code */
      }

  </style>

</head>
<body>

<div class="reveal">
  <div class="slides">
    <section data-background-transition="slide" data-background="assets/adt_pattern_matching_java.webp"></section>
    <section><h3>Domain Modelling</h3>
      <section>
        <aside class="notes" contenteditable>
          <h2>When we develop an application</h2>
          <ul>
            <li>Model a business problem.</li>
            <li>Create a conceptual representation of the real-world.</li>
            <li>Understand the "domain" where our software operates.</li>
            <li>Like creating a blueprint before constructing a building.</li>
            <li>Identify elements, relationships, interactions</li>
            <li>Guides the software design and ensures it accurately reflects the business problem.</li>
          </ul>
        </aside>
      </section>
      <section>
        <ol>
          <li class="fragment custom blur highlight-current-green" data-fragment-index="1">Identify Key
            Concepts
          </li>
          <li class="fragment custom blur highlight-current-green" data-fragment-index="2">Create a Model</li>
          <li class="fragment custom blur highlight-current-green" data-fragment-index="3">Define Attributes
            and Behaviour
          </li>
          <li class="fragment custom blur highlight-current-green" data-fragment-index="4">Refine the Model
          </li>
        </ol>
        <aside class="notes" contenteditable>
          <h2>Essential steps</h2>
          <ul>
            <li>Start by identifying the important concepts, entities, and relationships within the
              domain.
            </li>
            <li>Model these concepts and their relationships using diagrams. classes</li>
            <li>For each concept, we define its attributes (properties) and behaviour (actions).</li>
            <li>Refine the model iteratively based on feedback, further analysis, and discussions with
              domain experts.
            </li>
          </ul>
        </aside>
      </section>
    </section>
    <section>
      <h3>Relating to Types and Objects</h3>
      <section>
        <ul>
          <li class="fragment custom blur " data-fragment-index="1">
            Concepts<span class=" fragment custom blur highlight-green"
                          data-fragment-index="2"> =>  Types </span>
          </li>
          <li class="fragment custom blur " data-fragment-index="3">Instances<span
              class="fragment custom blur highlight-green"
              data-fragment-index="4"> => Objects </span>
          </li>
          <li class="fragment custom blur " data-fragment-index="5">
            Attributes <span class="fragment custom blur highlight-green" data-fragment-index="6"> => Properties (fields) </span>

          </li>
          <li class="fragment custom blur " data-fragment-index="7">
            Behaviour <span class="fragment custom blur highlight-green"
                            data-fragment-index="8"> => Methods </span>
          </li>
        </ul>
        <aside class="notes" contenteditable>
          <h2> Domain modelling is closely tied to the concepts of types and objects in object-oriented programming:</h2>
          <ul>
            <li>(Concepts) in the domain model often translate directly into types (classes) in our code. For example, the “Book” concept might become a Book
              class.
            </li>
            <li>(Instances) of these types represent specific objects in the domain. Each Book object would represent a particular book in the library.</li>
            <li>(Attributes) Attributes in the domain model become properties (fields) of the class.</li>
            <li>(Behaviour) The behaviour defined in the domain model is implemented as methods in the class.
            </li>
          </ul>
        </aside>
      </section>

    </section>
    <section>
      <h3>Relating to an Algebra</h3>
      <section>
        <h4 class="fragment custom blur highlight-blue" data-fragment-index="1">Algebraic Structures</h4>
        <p class="fragment custom blur highlight-current-green" data-fragment-index="2">Types => Sets</p>
        <p class="fragment custom blur highlight-current-green" data-fragment-index="3">Relationships =>
          Functions</p>
        <p class="fragment custom blur highlight-current-green" data-fragment-index="4">Operations</p>
        <p class="fragment custom blur highlight-current-green" data-fragment-index="5">Laws & Properties</p>
        <aside class="notes" contenteditable>
          <h2>Algebraic Structures:</h2>
          <p> The relationship between a domain model and an algebra might seem abstract at first, but it’s a powerful concept with practical implications in
            software design, especially when dealing with complex systems.</p>
          <ul>
            <li>(Types as Sets) In the domain model, each concept (e.g., “Customer,” “Product,” “Order”) we can think of as a set of possible values. For
              instance, “Customer” represents the set of all possible customers.
            </li>
            <li>(Relationships as Functions) Relationships between concepts can be modelled as functions. For example, an “Order” might have a function
              getCustomer() that maps an order to its corresponding customer.
            </li>
            <li>(Operations) An algebra defines operations on these sets. In an e-commerce example, we might have operations like “add product to order,”
              “calculate total price,” or “apply discount.”
            </li>
            <li>(L&P) These operations adhere to certain laws and properties. These laws reflect the business rules and constraints of your domain.
            </li>
          </ul>
        </aside>
      </section>
    </section>
    <section><h3>Relating to an Algebra</h3>
      <section>
        <h4 class="fragment custom blur highlight-blue" data-fragment-index="1">Connecting the Pieces</h4>
        <p class="fragment custom blur highlight-current-green" data-fragment-index="2">Domain model informs the Algebra</p>
        <p class="fragment custom blur highlight-current-green" data-fragment-index="3">Algebra provides Structure</p>
        <p class="fragment custom blur highlight-current-green" data-fragment-index="4">Implementation</p>
        <aside class="notes" contenteditable>
          <h2>Putting it all together</h2>
          <p> The relationship between a domain model and an algebra might seem abstract at first, but it’s a powerful concept with practical implications in
            software design, especially when dealing with complex systems.</p>
          <ul>
            <li>The domain model provides the basis for defining the sets and operations in the algebra. It ensures that the algebra accurately reflects our
              real-world problem.
            </li>
            <li>The algebraic structure helps us reason about the behaviour of your system and ensures consistency. For example, the “add product to order”
              operation might need to be associative (the order in which you add products shouldn’t matter).
            </li>
            <li>In code, we implement the algebra using classes, methods, and data structures. The algebraic laws guide the implementation and help you avoid
              inconsistencies.
            </li>
          </ul>
        </aside>
      </section>
    </section>
    <section><h3>Relating to an Algebra</h3>
      <section>
        <h4 class="fragment custom blur highlight-blue" data-fragment-index="1">Benefits of this Approach</h4>
        <ul><
          <li class="fragment custom blur highlight-current-green" data-fragment-index="2">Rigour and Precision</li>
          <li class="fragment custom blur highlight-current-green" data-fragment-index="3">Testability</li>
          <li class="fragment custom blur highlight-current-green" data-fragment-index="4">Maintainability</li>
        </ul>
        <aside class="notes" contenteditable>
          <h2>What does this give us?</h2>
          <p> The relationship between a domain model and an algebra might seem abstract at first, but it’s a powerful concept with practical implications in
            software design, especially when dealing with complex systems.</p>
          <ul>
            <li>(R&P) Using an algebraic approach brings rigour and precision to the domain model. It helps us clearly define the behaviour of a system.</li>
            <li>(Testability)Algebraic laws can be used to create comprehensive test cases, ensuring that your implementation adheres to the domain rules.</li>
            <li>(Maintainability)A well-defined algebra makes code more modular and easier to maintain. Changes in the domain can be reflected by modifying the
              algebra and its implementation.
            </li>
          </ul>
        </aside>
      </section>
    </section>
    <section><h3>Banking Example</h3>
      <section>
        <div class="fragment custom blur " data-fragment-index="1">
          <h4>Domain Concepts</h4>
          <p class=" fragment custom blur highlight-green" data-fragment-index="2">Account, Transaction,
            Balance </p>
        </div>
        <div class="fragment custom blur " data-fragment-index="3">
          <h4>Operations</h4>
          <p class=" fragment custom blur highlight-green" data-fragment-index="4">deposit, withdraw,
            transfer</p>
        </div>
        <aside class="notes" contenteditable>
          <h2>Consider a banking system. </h2>
          <ul>
            <li>Your domain model might include concepts like “Account” and “Transaction.”</li>
            <li>We could define an algebra with operations like “deposit,” “withdraw,” and “transfer.” These operations would need to satisfy certain laws</li>
          </ul>
        </aside>
      </section>
      <section>
        <div class="fragment custom blur " data-fragment-index="1">
          Algebraic laws: Consistency<p class="fragment custom blur highlight-green" data-fragment-index="2">
          withdraw operation requires sufficient funds </p>
        </div>
      </section>
      <section>
        <div class="fragment custom blur " data-fragment-index="1">
          Algebraic laws: Associativity<p class="fragment custom blur highlight-green" data-fragment-index="2">
          Multiple deposits and withdrawals result in same final balance regardless of order</p>
        </div>
      </section>
      <aside class="notes" contenteditable>
        <p>By implementing these algebraic laws in our code, we ensure that the banking system behaves correctly and consistently.</p>
      </aside>
    </section>
    <section><h3>Algebraic Data Types</h3>
      <section>
        <aside class="notes" contenteditable>
          <h2>Algebraic Data Types (ADTs) are a way to structure data in functional programming languages.</h2>
          <p>They provide a mechanism to create composite data types by combining other simpler types. </p>
          <p>ADTs help us to model complex data structures using simpler building blocks, much like building with LEGO. </p>
          <p>Think of them as custom, compound data types that you design for your specific needs.</p>
        </aside>
      </section>
      <section>
        <h4 class="fragment custom blur highlight-blue" data-fragment-index="1">Benefits</h4>
        <ul>
          <li class="fragment custom blur highlight-current-green" data-fragment-index="2">Readability</li>
          <li class="fragment custom blur highlight-current-green" data-fragment-index="3">Constraint Enforcement</li>
          <li class="fragment custom blur highlight-current-green" data-fragment-index="4">Reduce Boilerplate</li>
        </ul>
        <aside class="notes" contenteditable>
          <ul>
            <li>(Readability) make code more readable by explicitly defining the structure and possible values of complex data. This makes it easier to
              understand and reason about the code, improving maintainability.
            </li>
            <li>(C E) The compiler can detect errors at compile time, preventing runtime issues that might arise from invalid data structures or operations.
            </li>
            <li>(R B) Compared to using classes or structs alone, ADTs can often reduce the amount of boilerplate code needed to define and manipulate complex
              data. For example, pattern matching with ADTs often eliminates the need for lengthy if-else chains or switch statements.
              ADTs accurately model data that has a limited set of possible states or variations.
            </li>
          </ul>
          <p>In essence, ADTs help us model the application domain by defining custom data types that are tailor-made for a specific application and enforced by
            the type system. They provide a powerful tool for tackling complexity in software engineering.</p>
        </aside>
      </section>
      <section>
        <h4 class="fragment custom blur highlight-blue" data-fragment-index="1">Why Algebraic?</h4>
        <ul>
          <li class="fragment custom blur highlight-current-green" data-fragment-index="2">Objects</li>
          <li class="fragment custom blur highlight-current-green" data-fragment-index="3">Operations</li>
          <li class="fragment custom blur highlight-current-green" data-fragment-index="4">Laws</li>
        </ul>
        <aside class="notes" contenteditable>
          <h2>Why Algebraic?</h2>
          <ul>
            <li>Objects: The types that make up the algebra.</li>
            <li>Operations: The ways to combine types to create new types.</li>
            <li>Laws: The relationships between the types and the operations.</li>
          </ul>
        </aside>
      </section>
      <section>
        <div class="highlight-blue fragment" data-fragment-index="1">
          The algebra consists of two primary operators
        </div>
        <ul class="fragment" data-fragment-index="2">
          <li>Product (represented by "×" or "and")</li>
          <li>Sum (represented by "+" or "or")</li>
        </ul>
      </section>
    </section>
    <section>
      <h4>Product Type</h4>
      <section>
        <p class="fragment custom blur highlight-current-green" data-fragment-index="1"> Think of it as an “AND”
          relationship.</p>
        <p class="fragment custom blur highlight-current-green" data-fragment-index="2">Point is a product
          type consisting of an x AND y coordinate.</p>
        <p class="fragment custom blur highlight-current-green" data-fragment-index="4">tuples, POJOs, structs, or records</p>
        <aside class="notes" contenteditable>
          <h2>Product Type</h2>
          <ul>
            <li>Logical AND operator.</li>
            <li>Product types bundle two or more arbitrary types together such that T = A AND B AND C.</li>
            <li>In code, we see this as tuples, POJOs, structs, or records. In set theory, this is the Cartesian product..</li>
          </ul>
        </aside>
      </section>

      <section>
         <pre><code class="java" data-trim data-noescape data-line-numbers>
  public record TextStyle(Weight weight, Font font){}
  public enum Font { SERIF, SANS_SERIF, MONOSPACE }
  public enum Weight { NORMAL, LIGHT, HEAVY }
         </code></pre>
        <div class="fragment custom blur highlight-current-green" data-fragment-index="1">
          <pre><code>TextStyle = Weight ⨯ Font</code></pre>
        </div>
        <div class="fragment custom blur highlight-current-green" data-fragment-index="1">
          <pre><code>9 = 3 x 3</code></pre>
        </div>
        <aside class="notes" contenteditable>
          <h2>Product Type</h2>
          This is called a product type because the set of all possible values is the Cartesian product of the possible values of its components.
        </aside>
      </section>
    </section>
    <section>
      <h4>Sum Type</h4>
      <section>
        <p class="fragment custom blur highlight-current-green" data-fragment-index="1"> Think of it as an “OR”
          relationship.</p>
        <p class="fragment custom blur highlight-current-green" data-fragment-index="2"> A Shape could be a Circle OR a Square OR a Triangle.</p>
        <p class="fragment custom blur highlight-current-green" data-fragment-index="3">Defines variants.</p>

        <aside class="notes">
          <p>Sum types represent a choice between different types, where a value can be one of several possible types, but only one at a time.</p>

          <ul>
            <li>Logical OR operator.</li>
            <li>Sum types are built with the ‘+’ operator and combine types with OR, as in T = A OR B OR C.</li>
            <li>A Shape might be a sum type, as it could be a Circle OR a Square OR a Triangle.</li>
          </ul>
          <p>The sum is the union of the value sets of the alternatives.</p>
          <p>
            Traditionally, sum types are more common in functional languages like Haskell (as data types) or Scala (as sealed traits of case classes).
          </p>
        </aside>
      </section>
      <section>
        <div class="fragment custom blur highlight-current-green" data-fragment-index="1">
          <pre><code> Type A = Integer | Boolean </code></pre>
          <pre><code> Type B = String | Float </code></pre>
        </div>
        <div class="fragment custom blur highlight-current-green" data-fragment-index="2">
          <pre><code> Type C = A + B </code></pre>
        </div>
        <div class="fragment custom blur highlight-current-green" data-fragment-index="3">
          <pre><code> 4 = 2 + 2</code></pre>
        </div>

        <aside class="notes">
          <ul>
            <li>Holds any of the four possible values: Integer, Boolean, String, or Float.</li>
            <li>Its commutative A + B = B + A</li>
            <li>This is a Sum because the number of items in the resulting type is the sum of the number of items in each subtype.</li>
          </ul>
        </aside>
      </section>
    </section>
    <section>
      <h4>Combining Product and Sum Types</h4>
      <section>
        <pre><code class="haskel" data-trim data-noescape>
DnsRecord(AValue(ttl, name, ipv4)
          | AaaaValue(ttl, name, ipv6)
          | CnameValue(ttl, name, alias)
          | TxtValue(ttl, name, value))
        </code></pre>
        <aside class="notes">
          <p>For example, we could define a DNS Record as a sum type:</p>
        </aside>
      </section>
      <section>
      <pre><code class="haskel" data-trim data-noescape>
DnsRecord(ttl, name, AValue(ipv4)
          | AaaaValue(ipv6)
          | CnameValue(alias)
          | TxtValue(value))
      </code></pre>
        <aside class="notes">
          <p> But we could also refactor it to a product of a product and sums:</p>
        </aside>
      </section>
      <section>
        <h4>Distributive</h4>
        <p>
          \( \color{orange} (a \cdot b + a \cdot c) \Leftrightarrow a \cdot (b + c) \)
        </p>
        <aside class="notes">
          <p>Product and sum types can be combined, and they follow the distributive law of numerical algebra</p>
        </aside>
      </section>
      <section>
        <h5>Commutative</h5>
        <p>
          \( \color{blue} (a \cdot b) \Leftrightarrow (b \cdot a) \)
          <br>
          \( \color{red} (a + b) \Leftrightarrow (b + a) \)
        </p>
        <aside class="notes">
          <p>At the type level we can change ordering in using the same commutative law we would in algebra</p>
        </aside>
      </section>
      <section>
        <h5>Associative</h5>
        <p>
          \( \color{green} (a + b) + c \Leftrightarrow a + (b + c) \)
          <br>
          \( \color{purple} (a \cdot b) \cdot c \Leftrightarrow a \cdot (b \cdot c) \)
        </p>
      </section>
      <!--            <aside class="notes">Shh, these are my private speaker notes here</aside>-->

    </section>
    <section>Algebraic Data Types

      <section>
        <h4 class="fragment custom blur highlight-blue" data-fragment-index="0">Modern Java</h4>
        <p class="fragment custom blur highlight-current-green" data-fragment-index="1">Records</p>
        <p class="fragment custom blur highlight-current-green" data-fragment-index="2">Sealed Interfaces</p>
        <p class="fragment custom blur highlight-current-green" data-fragment-index="3">Pattern Matching</p>
      </section>
      <aside class="notes">
        <ul>
          <li>(Records)Introduced in Java 14, records offer a concise syntax for defining immutable data carriers, providing nominal types and components with
            human-readable names.
          </li>
          <li>Introduced in Java 17, sealed interfaces allow classes and interfaces to have more control over their permitted subtypes.
            This enables precise data modelling as sealed hierarchies of immutable records. The compiler knows all possible subtypes at compile time, a crucial
            requirement for safe sum types.
          </li>
          <li>Pattern Matching: Pattern matching is a powerful feature that enhances Java’s instanceof operator and switch expressions/statements.
            It allows developers to concisely and safely extract data from objects based on their structure. This capability streamlines type checking and
            casting, leading to more readable and less error-prone code.
            The evolution of pattern matching in Java is noteworthy.
            Initially introduced in Java 16 to enhance the instanceof operator JEP 394, it was later extended to switch expressions and statements in Java 17
            JEP 406.
            This expansion broadened the applicability of pattern matching, enabling more expressive and safer code constructs.
          </li>
        </ul>
        <p>
          Restricting the possible implementations of a type enables exhaustive pattern matching and makes invalid states unrepresentable.
          This is particularly useful for general domain modelling with type safety.
        </p>
      </aside>


      <section>
        <h4>What about Enums?</h4>
        <pre><code class="java" data-trim data-noescape data-line-numbers>
enum Task {
  NotStarted,
  Started,
  Completed,
  Cancelled;
}

sealed interface TaskStatus{
  record NotStarted(...) implements TaskStatus
  record Started(...) implements TaskStatus
  record Completed(...) implements TaskStatus
  record Cancelled(...) implements TaskStatus
}
                </code>
            </pre>

      </section>
      <section>
        <pre>
                <code class="java" data-trim data-noescape data-line-numbers>
enum Planet {
  MERCURY (3.303e+23, 2.4397e6),
  VENUS (4.869e+24, 6.0518e6),
  EARTH (5.976e+24, 6.37814e6);

  private final double mass;   // in kilogram
  private final double radius; // in metres

  Planet(double mass, double radius) {
    this.mass = mass;
    this.radius = radius;
  }
  private double mass() { return mass; }
  private double radius() { return radius; }
}
              </code>
            </pre>
        <aside class="notes">
          <p>
            It is possible to associate fixed data with an enum constant, such as the mass and radius of the planet
          </p>
        </aside>
      </section>
      <section>
        <pre>
                <code class="java" data-trim data-noescape data-line-numbers>
sealed interface Celestial {
  record Planet(String name, double mass, double radius)
                  implements Celestial {}
  record Star(String name, double mass, double temperature)
                  implements Celestial {}
  record Comet(String name, double period)
                  implements Celestial {}
}
              </code>
            </pre>
        <aside class="notes">
          <p>
            sealed interfaces work at a higher level. Where enums enumerate a fixed list of instances, sealed records enumerate a fixed list of kinds of instances
          </p>
          <p>
            Unlike enums, records allow us to attach arbitrary attributes to each of the enumerated states. We are no longer restricted to fixed constants.
          </p><p>
            In the Celestial example, we see a sum of products. This is a useful technique for modelling complex domains in a flexible but type-safe manner.
            For sums of products to work, we have to commit to the subtypes, which is a form of tight coupling.
            This works well if we are sure the subtypes are unlikely to change.
            We trade some future flexibility for an exhaustive list of subtypes that allows better reasoning about shapes, especially when it comes to pattern matching.
          </p>
        </aside>
      </section>
    </section>
    <section><h4>The Visitor Pattern</h4>
      <section>
        <pre><code class="language-java fragment fade-out" data-noescape data-trim data-fragment-index="0">
sealed interface Shape
    permits Circle, Rectangle, Triangle, Pentagon {
  <T> T accept(ShapeVisitor<T> visitor);
}
            </code><code class="language-java fragment" data-noescape data-trim data-fragment-index="1">
interface ShapeVisitor<T> {
  T visit(Circle circle);
  T visit(Rectangle rectangle);
  T visit(Triangle triangle);
  T visit(Pentagon pentagon);
}
          </code></pre>
        <aside class="notes">
          <p>
            The Visitor pattern is a behavioral design pattern.
          </p>
          <p>
            Traditionally, Java developers used the Visitor pattern to handle operations on different data types within a hierarchy of objects without
            modifying the structure of those objects themselves. It achieves this by separating the operation's logic into a separate "visitor" class.
            However,
            this approach has several drawbacks, as we will see when we compare using a sum type with Pattern Matching
          </p>
          <ul>
            <li>Shape is a sealed interface, only permitting Circle, Rectangle, Triangle and Pentagon to implement it.</li>
            <li>ShapeVisitor Interface: Defines the visit methods for each shape type.
              The generic type T allows visitors to return different types of results.</li>
          </ul>
        </aside>
      </section>
      <section>
        <pre><code class="language-java fragment" data-noescape data-trim data-fragment-index="0">
record Circle(double r) implements Shape {

  public <T> T accept(ShapeVisitor<> visitor) {
    return visitor.visit(this);
  }
}
            </code><code class="language-java fragment" data-noescape data-trim data-fragment-index="1">
record Rectangle(double w, double h) implements Shape {

  public <T> T accept(ShapeVisitor<T> visitor) {
    return visitor.visit(this);
  }
}
            </code><code class="language-java fragment" data-noescape data-trim data-fragment-index="2">
record Triangle(double s1, double s2, double s3)
        implements Shape {

  public <T> T accept(ShapeVisitor<T> visitor) {
    return visitor.visit(this);
  }
}
            </code><code class="language-java fragment" data-noescape data-trim data-fragment-index="3">
record Pentagon(double s) implements Shape {

  public <T> T accept(ShapeVisitor<T> visitor) {
    return visitor.visit(this);
  }
}
        </code></pre>
        <aside class="notes">
          <p>
            Every concrete shape has to have the accept method which takes a ShapeVisitor and calls the appropriate visit method on the visitor.
          </p>

          <p>The Visitor pattern heavily relies on polymorphism, specifically double dispatch.  </p>
          <ol>
          <li>First Dispatch (Dynamic): When accept(visitor) is called the correct accept method is chosen at runtime based upon the actual type of shape. This is standard dynamic polymorphism. </li>
          <li>Second Dispatch (Within Visitor): Inside the accept method this is now statically known to the concrete shape type (e.g triangle).</li>
          </ol>
          <p>The compiler can statically choose the correct visit method in the Visitor to call, based upon the type of the current visitor, passed in as an argument to the accept() method.</p>
        </aside>
      </section>
      <section>
         <pre><code class="language-java fragment" data-noescape data-trim>
class AreaCalculator implements ShapeVisitor<Double> {

  public Double visit(Circle circle) {
    return PI * circle.r() * circle.r();
  }

  public Double visit(Rectangle rectangle) {
    return rectangle.w() * rectangle.h();
  }

  public Double visit(Triangle tri) {
    double s = (tri.s1() + tri.s2() + tri.s3()) / 2;
    return sqrt(s * (s - tri.s1()) * (s - tri.s2())* (s - tri.s3()));
  }

  public Double visit(Pentagon p) {
    return (0.25) * sqrt(5 * (5 + 2 * sqrt(5))) * p.s() * p.s();
  }
}
         </code><code class="language-java fragment" data-noescape data-trim>
class PerimeterCalculator implements ShapeVisitor<Double> {

  public Double visit(Circle circle) {
    return 2 * PI * circle.r();
  }

  public Double visit(Rectangle rectangle) {
    return 2 * (rectangle.w() + rectangle.h());
  }

  public Double visit(Triangle triangle) {
    return triangle.s1() + triangle.s2() + triangle.s3();
  }

  public Double visit(Pentagon pentagon) {
    return 5 * pentagon.side();
  }
}
         </code><code class="language-java fragment" data-noescape data-trim>
class InfoVisitor implements ShapeVisitor<String> {
  public String visit(Circle circle) {
    return "Circle with radius: %.2f, area: %.2f, perimeter: %.2f"
     .formatted(circle.r(), new AreaCalculator().visit(circle),
        new PerimeterCalculator().visit(circle));
  }

  public String visit(Rectangle rect) {
    return "Rectangle with width: %.2f , height: %.2f, area: %.2f, perimeter: %.2f"
     .formatted(rect.w(), rect.h(),
        new AreaCalculator().visit(rect),
        new PerimeterCalculator().visit(rect));
  }

  public String visit(Triangle tri) {
    return "Triangle with sides: %.2f, %.2f, %.2f, area: %.2f, perimeter: %.2f"
     .formatted(tri.s1(), tri.s2(), tri.s3(),
        new AreaCalculator().visit(tri),
        new PerimeterCalculator().visit(tri));
  }

  public String visit(Pentagon pentagon) {
    return "Pentagon with side: %.2f, area: %.2f, perimeter: %.2f"
        .formatted(pent.side(),
          new AreaCalculator().visit(pent),
          new PerimeterCalculator().visit(pent));
  }
}
        </code></pre>
        <aside class="notes">
          <h2> Concrete Visitors:</h2>
         <ul>
           <li>
             AreaCalculator: Calculates the area of a shape.
           </li>
           <li>
             PerimeterCalculator: Calculates the perimeter of a shape.
           </li>
           <li>
             InfoVisitor: Generates a string with information about the shape (including area and perimeter).
           </li>
         </ul>
        </aside>
      </section>
      <section>
        <pre><code class="language-java fragment " data-trim data-noescape data-fragment-index="1">
class Shapes {
  public static void main(String[] args) {
    List<Shape> shapes = List.of(new Circle(5), new Triangle(3, 3, 3), new Rectangle(3, 5), new Pentagon(5.6));
    InfoVisitor infoVisitor = new InfoVisitor();

    System.out.println("\nShapes:");
    shapes.stream().map(s -> s.accept(infoVisitor)).forEach(System.out::println);
  }
}
        </code>
          <code class="fragment" data-trim data-noescape data-fragment-index="2">
Shapes: [Circle[radius=5.0], Triangle[side1=3.0, side2=3.0, side3=3.0],
          Rectangle[width=3.0, height=5.0], Pentagon[side=5.6]]
Circle with radius: 5.00, area: 78.54, perimeter: 31.42
Triangle with sides: 3.00, 3.00, 3.00, area: 3.90, perimeter: 9.00
Rectangle with width: 3.00 , height: 5.00, area: 15.00, perimeter: 16.00
Pentagon with side: 5.60, area: 53.95, perimeter: 28.00
        </code></pre>
      </section>
    </section>
    <section>
      <h4>Pattern Matching</h4>
      <section>
            <pre><code class="language-java fragment" data-trim data-noescape>
sealed interface Shape
                permits Circle, Rectangle, Triangle, Pentagon {}

record Circle(double r) implements Shape {}
record Rectangle(double w, double h) implements Shape {}
record Triangle(double s1, double s2, double s3) implements Shape {}
record Pentagon(double s) implements Shape {}
            </code></pre>
        <aside class="notes">
          Here we have a sealed interface called 'Shape' representing different geometric shapes.
          Notice that we don't need and additonal method defined to do patten matching
        </aside>
      </section>

      <section>
             <pre><code class="language-java fragment" data-trim data-noescape>
static double area(Shape shape) {
  return switch (shape) {
    case Circle(var r) -> PI * r * r;
    case Rectangle(var w, var h) -> w * h;
    case Triangle(var s1, var s2, var s3) -> {
            double s = (s1 + s2 + s3) / 2;
            yield sqrt(s * (s - s1) * (s - s2) * (s - s3));}
    case Pentagon(var s) -> (0.25) * sqrt(5 * (5 + 2 * sqrt(5))) * s * s;
   };
}
                   </code></pre>
        <aside class="notes">
          This code demonstrates a switch expression, enhanced to work with our sealed interface.
          Each 'case' handles a specific shape by deconstructing the record's components directly in the 'case' label.
          For instance, 'Circle(var r)' extracts the radius.
          We calculate the area accordingly, and thanks to the 'permits' clause in our 'Shape' definition, the compiler guarantees we've covered all possible shape types here, making our switch exhaustive.
          Also, notice the 'yield' keyword in the 'Triangle' case. 'yield' is used here because we have a multi-line statement block for the calculation of the area of the Triangle.
        </aside>
      </section>
      <section>
               <pre><code class="language-java fragment" data-trim data-noescape>
 static double perimeter(Shape shape) {
    return switch (shape) {
      case Circle(var r) -> 2 * PI * r;
      case Rectangle(var w, var h) -> 2 * (w + h);
      case Triangle(var s1, var s2, var s3) -> s1 + s2 + s3;
      case Pentagon(var s) -> 5 * s;
    };
  }
               </code></pre>
      </section>
      <section>
               <pre><code class="language-java fragment" data-trim data-noescape>
   static String info(Shape shape) {
    return switch (shape) {
      case Circle c ->
          "Circle with radius: %.2f, area: %.2f, perimeter: %.2f
             .formatted(c.r(), area(c), perimeter(c));
      case Rectangle r ->
          "Rectangle with width: %.2f , height: %.2f, area: %.2f, perimeter: %.2f"
             .formatted(r.w(), r.h(), area(r), perimeter(r));
      case Triangle t ->
          "Triangle with sides: %.2f, %.2f, %.2f, area: %.2f, perimeter: %.2f"
             .formatted(t.s1(), t.s2(), t.s3(), area(t), perimeter(t));
      case Pentagon p ->
          "Pentagon with side: %.2f, area: %.2f, perimeter: %.2f"
             .formatted(p.s(), area(p), perimeter(p));
    };
               </code></pre>
      </section>

    </section>
    <section>
      <h4>The Expression Problem</h4>
      <h4 class="fragment custom blur highlight-blue" data-fragment-index="1">The challenge of extending data
        structures and operations independently.</h4>

      <ul>
        <li class="fragment custom blur  highlight-current-green" data-fragment-index="1">
          <strong>Add new data types</strong> Without modifying existing code that operates on those data
          types.
        </li>
        <li class="fragment custom blur highlight-current-green" data-fragment-index="2">
          <strong>Add new operations</strong> Without modifying existing data types.
        </li>
      </ul>
      <aside class="notes">
        The Expression Problem is a fundamental challenge in software design.
        Essentially, it's about how difficult it can be to add both new data types AND new operations that work on those types without constantly having to change existing code.
        Ideally, we want our code to be flexible enough to accommodate these extensions independently.
      </aside>
    </section>
    <section><h4>Visitor Pattern</h4>
      <section>
        <p class="fragment custom blur highlight-current-green" data-fragment-index="1">Adding new operations
          (Easy)</p>
        <p class="fragment custom blur highlight-current-green" data-fragment-index="2">Adding new data type
          (Hard)</p>
        <p class="fragment custom blur highlight-current-green" data-fragment-index="3">Verbose</p>
        <p class="fragment custom blur highlight-current-green" data-fragment-index="4">No Exhaustiveness
          Checking</p>
        <aside class="notes">
          Let's talk about the trade-offs of the Visitor pattern.
          It excels when you need to add new operations frequently, as it doesn't require modifying existing classes.
          However, adding new data types (shapes in our previous example) is cumbersome, as you have to update all your visitors.
          It's also known for being quite verbose due to the double dispatch mechanism.
          Finally, a major drawback is the lack of exhaustiveness checking; the compiler won't warn you if a visitor doesn't handle all possible types.
        </aside>
      </section>
    </section>
    <section><h4>Pattern Matching</h4>
      <section>
        <p class="fragment custom blur highlight-current-green" data-fragment-index="1">Adding new operations
          (Easy)</p>
        <p class="fragment custom blur highlight-current-green" data-fragment-index="2">Adding new data type
          (Easier)</p>
        <p class="fragment custom blur highlight-current-green" data-fragment-index="3">More concise</p>
        <p class="fragment custom blur highlight-current-green" data-fragment-index="4">Exhaustiveness
          Checking</p>
      </section>
      <aside class="notes">
        Let's wrap up the benefits of pattern matching, especially when combined with sealed types.
        We see that adding new operations is straightforward.
        But now, thanks to sealed types and records, adding new data types becomes even simpler.
        The code is generally more concise and readable.
        And critically, the compiler helps us with exhaustiveness checking, ensuring we handle all possible cases, which boosts code safety.
      </aside>
    </section>
    <section data-background-color="aquamarine">
      <h2>🍦</h2>
    </section>
    <section data-background-color="rgb(70, 70, 255)">
      <h2>🍰</h2>
    </section>
    <section>
      <section data-background-gradient="linear-gradient(to bottom, #283b95, #17b2c3)">
        <h2>🐟</h2>
      </section>
      <section data-background-gradient="radial-gradient(#283b95, #17b2c3)">
        <h2>🐳</h2>
      </section>
    </section>

  </div>
</div>

<script src="dist/reveal.js"></script>
<script src="plugin/notes/notes.js"></script>
<script src="plugin/markdown/markdown.js"></script>
<script src="plugin/highlight/highlight.js"></script>
<script src="plugin/math/math.js"></script>
<script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/

    Reveal.initialize({
        hash: true,
        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.KaTeX]
    });
</script>
</body>
</html>
